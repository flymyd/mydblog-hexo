---
title: 生成式人工智能入门
toc: true
date: 2024-06-12 00:00:00
tags: [AI, LLM, 综述]
categories:
  - [AI研究]
---

# 前言

以下是文章中可能提及到的关键词及对应缩写：

| 中文名                 | 英文名                                     | 缩写 |
| :--------------------- | :----------------------------------------- | :--- |
| 人工智能               | Artificial Intelligence                    | AI   |
| 生成式人工智能         | Generative Artificial Intelligence         | GAI  |
| 通用人工智能           | Artificial General Intelligence            | AGI  |
| 人工智能生成内容       | AI Generated Content                       | AIGC |
| 基于人类反馈的强化学习 | Reinforcement Learning with Human Feedback | RLHF |
| 大语言模型             | Large Language Model                       | LLM  |

# 一、概述  

2022年11月30日，ChatGPT上线。马斯克在12月3日发布了一条twitter，成为了ChatGPT火遍全球的导火索，火到自11月30日上线不到5天就突破百万人的注册使用。  

## ChatGPT、GPT和LLM分别是什么？它们的关系是什么？
- GPT即Generative Pre-trained Transformer。Generative 即生成式，指该模型可以生成新的内容；Pre-trained 即预训练，指该模型可以进行预先训练；Transformer 则是近年来主流的深度学习模型。GPT取得突破的一大原因，是引入了新技术RLHF（基于人类反馈的强化学习），使人工智能模型的输出内容和人类的常识、认知、需求、价值观等相一致， 让人难以分辨输出者是人类还是机器。
- ChatGPT则是由OpenAI公司开发的一个人工智能聊天机器人程序。它能够通过学习和理解人类的语言来进行对话互动交流，甚至能完成撰写邮件、文案、翻译、代码等任务。ChatGPT背后的驱动模型分为很多型号。对于对话交流能力来说，驱动它的模型属于GPT模型。
- LLM，即大语言模型，旨在理解和生成人类语言。LLM的特点是规模庞大，包含成百、上千亿的参数，可以捕捉语言的复杂模式，包括句法、语义和一些上下文信息，从而生成连贯的、有意义的文本。ChatGPT、GPT-4、BERT、文心一言等都是典型的大型语言模型。
  所以说，并不是所有的LLM服务都叫做ChatGPT。
  
## GAI、AGI和AIGC分别是什么？它们的关系是什么？  
- GAI，即生成式人工智能，这是一种利用AI生成新的、未曾存在的数据（如文本、图像、音乐等）的技术。GAI强调的是通过机器学习模型，特别是深度学习模型如生成对抗网络（GANs）或变分自编码器（VAEs），来创造出贴近或超越现实质量的内容。GAI的应用示例包括生成逼真的图像、创作音乐、写作故事等。例如：Stable Diffusion、Midjourney等AI绘图应用和ChatGPT、Claude等AI对话应用等。
- AGI，即通用人工智能，指的是一种理论上的AI系统，这种系统能够理解、学习和应用任何智力任务，就像一个成人或超越人类智能水平一样。AGI具有广泛的适应性和泛化能力，能够在没有特定培训的情况下执行各种复杂任务。AGI的目标是创造一个能像人类一样思考、学习、执行多种任务的系统，成为全能的“超级大脑”，未来可能在任何领域都超越人类。
- AIGC，即AI生成内容，聚焦于使用人工智能生成内容的领域，可以看作是GAI的一个子集或应用领域。它主要关注利用AI技术自动生成具有创造性的内容，如文本、图像、音乐等。AIGC的目标是提高内容创作的质量和效率，通常依赖于特定的数据和算法模型来实现。
- GAI与AIGC的关系较为紧密，因为GAI的生成式技术是实现AIGC的关键。GAI的技术和算法为AIGC提供了生成新颖内容的能力。
- AGI与GAI和AIGC的关系较为宽泛，因为AGI的目标是创建一种具有全面理解和学习能力的智能系统，而不仅仅是生成特定类型的内容。AGI在理论上能够执行GAI和AIGC的任务，但它的目标和应用范围更广泛。

## 大模型与小模型
关于大模型，有学者称之为“大规模预训练模型”(large pretrained language model），也有学者进一步提出”基础模型”(Foundation Models)的概念。
2021年8月，李飞飞、Percy Liang等百来位学者联名发布了文章：On the Opportunities and Risks of Foundation Models[1]，提出“基础模型”(Foundation Models)的概念：基于自监督学习的模型在学习过程中会体现出来各个不同方面的能力，这些能力为下游的应用提供了动力和理论基础，称这些大模型为“基础模型”。
- 小模型：针对特定应用场景需求进行训练，能完成特定任务，但是换到另外一个应用场景中可能并不适用，需要重新训练（我们现在用的大多数模型都是这样）。这些模型训练基本是“手工作坊式”，并且模型训练需要大规模的标注数据，如果某些应用场景的数据量少，训练出的模型精度就会不理想。
- 大模型：在大规模无标注数据上进行训练，学习出一种特征和规则。基于大模型进行应用开发时，将大模型进行微调（在下游小规模有标注数据进行二次训练）或者不进行微调，就可以完成多个应用场景的任务，实现通用的智能能力。可以这么类别，机器学习同质化学习算法（例如逻辑回归）、深度学习同质化模型结构（例如CNN），基础模型则同质化模型本身（例如GPT-3）。

## AIGC都能做什么？
下面示例了AIGC能做的事情：

![AIGC介绍](AIGC介绍.png)

# 二、大语言模型（LLM）

## 技术介绍

LLM，即大型语言模型（Large Language Models），是人工智能领域的一种先进自然语言处理技术，它们通过深度学习方法，特别是基于Transformer架构的神经网络模型，来理解和生成人类语言。这类模型因其强大的语言理解和生成能力，在诸多应用场景中展现出巨大潜力，如自动回复、文本创作、机器翻译、摘要生成等。

### 技术基础

1. 深度学习与神经网络：LLM的核心是深度学习，尤其是使用了Transformer架构的神经网络。Transformer模型最初由Vaswani等人在2017年提出，它摒弃了传统的循环网络结构，通过自注意力（Self-Attention）机制并行处理输入序列，大大提高了处理速度和模型容量。
2. 大规模预训练：LLM的一个关键特点是其基于大规模无监督数据的预训练。模型在互联网文本、书籍、新闻等海量数据上进行训练，学习语言的一般规律和模式，而不是针对特定任务。这使得模型能够捕捉到丰富的语言结构和语义信息。
3. 微调（Fine-tuning）：虽然预训练赋予了模型广泛的语言理解能力，但针对特定任务时，通常会对预训练好的模型进行微调，即在特定领域的有标签数据集上进行额外训练，以优化模型在该任务上的性能。

### 原理概述

1. 自注意力机制：这是Transformer模型的核心组件，允许模型在处理一个词时，考虑句子中所有其他词的上下文，从而更好地理解词汇之间的关系和依赖。
2. 多层编码解码：LLM通常包含多层的编码器和解码器结构。编码器负责将输入文本转换为一系列连续的向量表示，而解码器则基于这些向量生成输出文本。每一层都包含自注意力和前馈神经网络组件，层层深入地提取和处理语言特征。
3. 位置编码：由于Transformer模型本身不保留输入序列的顺序信息，因此引入了位置编码机制，确保模型能够区分不同位置的词语，正确理解语序。
4. 海量参数：现代的LLM，如GPT-3、BERT等，拥有数十亿乃至上千亿的参数量。这些庞大的参数使模型能够学习到更复杂、更细腻的语言规律，实现更高质量的语言生成和理解。

## 一些AI资源站

- AI工具集（https://ai-bot.cn/）
- AI工具箱（https://www.phpcms9.com/ai/chatgpt）
- AI工具箱2（https://www.ailookme.com/）

## 推荐的国产大语言模型在线使用（与GPT4接近或近似持平）
- 通义千问（支持联网，效果很好！）：https://tongyi.aliyun.com/qianwen/
- Deepseek（有针对代码finetune的模型；通用对话效果也很好；生成速度快；API超级便宜适合二次开发接入使用）：https://chat.deepseek.com/

## Prompt
在大型语言模型（LLMs）的上下文中，"Prompt"是指提供给模型的输入文本，用于引导模型生成特定的输出或执行特定的任务。Prompt设计是使用这些模型的一个关键方面，因为它直接影响到模型输出的质量和相关性。

### Prompt的作用
1. 指导模型：Prompt为模型提供了一个起点，告诉模型用户期望的输出类型或任务。
2. 限制输出：通过精心设计的Prompt，可以限制模型的输出范围，使其更符合特定的需求。
3. 提高效率：一个好的Prompt可以减少模型生成无关或不准确输出的可能性，从而提高交互的效率。

### Prompt的设计原则
1. 清晰性：Prompt应该清晰明确，避免歧义，以便模型能够准确理解用户的意图。
2. 具体性：提供具体的细节或指令，可以帮助模型更好地聚焦于任务。
3. 上下文信息：在Prompt中包含相关的上下文信息，可以帮助模型生成更连贯和相关的输出。
4. 示例：有时，提供一个或多个示例可以帮助模型理解期望的输出格式或风格。

### Prompt的类型
1. 开放式Prompt：这类Prompt通常只提供一个主题或问题，允许模型自由生成内容。
2. 封闭式Prompt：这类Prompt提供更具体的指令或问题，限制模型的回答范围。
3. 示例Prompt：这类Prompt包含一个或多个示例，用于指导模型生成相似的输出。
4. 多轮对话Prompt：在对话系统中，Prompt可能包括之前的对话历史，以保持对话的连贯性。

### 使用Prompt的技巧
1. 逐步细化：如果模型的初始输出不理想，可以通过添加更多细节或指令来逐步细化Prompt。
2. 迭代反馈：根据模型的输出调整Prompt，可以逐步优化结果。
3. 利用模型的知识：了解模型的能力和限制，可以设计出更有效的Prompt。

### 示例
假设我们想要使用一个语言模型来生成一段关于气候变化的描述，我们可以设计以下Prompt：
- 开放式Prompt：“请描述气候变化的影响。”
- 封闭式Prompt：“请列出气候变化对农业的三个主要影响。”
- 示例Prompt：“像这样描述气候变化对海平面的影响：‘气候变化导致全球平均温度上升，进而引起冰川融化，增加了海平面。’请用类似的方式描述气候变化对极端天气事件的影响。”

通过精心设计的Prompt，可以有效地利用大型语言模型来完成各种复杂的自然语言处理任务。

## 干货：Prompt调教指南
### 一、提示词应该怎么写？
#### 1.提出任务
我们把LLM想象成是一个可以自然交流的真人。
假设我们要让LLM帮我们生成一个随机数，就可以直接用自然语言要求LLM：”生成一个随机数”。
可以看到，它很好的完成了任务。
```text
Q：生成一个随机数
A：当然！这里是一个随机数：47。
```
然而，如果我们新建一个对话，再问一遍相同的问题。
这次有点儿不一样，虽然问题一样，但是这次大模型没有直接生成一个随机数，而是询问我们随机数的范围。
```text
Q：生成一个随机数
A：当您说“随机数”，您是否指的是一个介于特定范围的随机整数？如果是这样，请提供所需的范围。
```

#### 2.描述细节
为什么两次的结果不一样呢？
因为我们只提出了任务，而没有描述这个任务的细节，比如这个随机数的范围，LLM自然就会犯迷糊。
假设现在我直接要求正在阅读这篇文档的你，”生成一个随机数”，你会是什么反应呢？
1. 不假思索的直接回答：47！
2. 添油加醋一番：我可以随机给你一个随机数，这个数是47。
3. 也可能比较疑惑：你想要范围在什么之间的随机数？它是整数还是小数？可以为负数吗？
LLM和我们一样，如果我们没有为它限定任务的细节，它就可能产生不明确/不稳定的输出。
现在我们修改一下提问的方式，再试一次。
```text
Q：生成一个随机数，它要在1234到5678之间，是个整数
A：生成一个在1234到5678之间的整数随机数，可以使用以下代码（使用Python语言）：
random_number = random.randint(1234, 5678)
print(random_number)
执行这段代码将生成一个介于1234到5678之间的整数随机数，并将其打印输出。
```
好吧，这次的结果还不如上次，因为我们描述的细节还不够详细，LLM认为我们的要求是写一段生成随机数的代码。
描述的再仔细一点，重新试一下。
```text
Q：你的任务是直接生成一个随机数，它要在1234到5678之间，是个整数
A：好的，我将为您生成一个在1234到5678之间的随机整数。请稍等片刻。
生成的随机整数为：4421
```
虽然LLM生成了随机数，但是它太能添油加醋了，输出了好多无关内容。
现在我们继续向它提要求：不要做什么。
```text
Q：你的任务是直接生成一个随机数，它要在1234到5678之间，是个整数，不要输出随机数以外的任何内容。
A：2132
```
#### 3.更准确的描述细节
可以看出，让LLM遵从你的想法的根本就是：尽可能清晰的描述任务，以及任务的细节。
##### 指导LLM完成复杂任务
随机数的示例可能玩腻了，我们换个场景，来充当HR，让大模型帮我们写招聘要求。
```text
Q：为我写一个招聘JD
A：xxxxxxx此处省略
```
在上面的例子中，如果你多尝试几次，就会得到完全不同的答案。
因为这个任务的描述过于模糊：招聘的是前端还是后端？校招还是社招？需要什么技术栈？这些都没有给出，LLM就会放飞自我了。
提出详细的要求，再试一次。
```text
Q：为我写一个后端的招聘JD，你要考虑到以下几点：
描述职位的职责
列出所需的编程语言
对数据库管理系统了解
有团队协作精神
本科学历及以上，2年经验
A：职位名称：后端开发工程师
职责描述：
设计、开发和维护高效、可靠的后端应用程序和系统。
编写清晰、可维护的代码，并进行代码审查和优化。
开发和实现数据库结构和存储过程，确保数据的一致性和完整性。
与前端团队合作，协调接口和数据交互的需求。
进行故障排查和问题解决，确保系统的稳定性和可用性。
进行技术调研和学习，保持对最新技术和开发工具的了解。

所需编程语言：
熟练掌握至少一种主流后端编程语言，如Java、Python、Node.js等。
对多种编程语言有基本的了解和适应能力。

数据库管理系统：
具备良好的数据库设计和管理技能，熟悉关系型数据库（如MySQL、PostgreSQL）和非关系型数据库（如MongoDB、Redis）。
能够编写高效的SQL查询语句，进行数据库性能优化。

团队协作精神：
具备良好的沟通和合作能力，能够与团队成员紧密合作，共同完成项目。
具备问题解决和决策能力，能够在团队协作中提供积极的贡献。

学历和经验：
本科学历及以上，计算机科学或相关专业优先考虑。
至少2年以上相关后端开发经验，有独立开发和维护后端系统的能力。
具备良好的学习能力和自我驱动能力，能够不断提升自己的技术水平。
```
##### 给出清晰的界限
好的，不能只满足于人工打字与大模型玩耍了，因为这样的成本太高，一点都不Geek。
现在我们来开发一个翻译软件，用户输入一句话，让LLM来翻译文本。
```text
Q：请将下面的文本翻译为英文：
你好，世界！
A：Hello, world!
```
我们将LLM投入到生产的时候，往往输入的prompt是会变化的。
例如开发人员需要将用户输入的句子交给LLM来翻译，可以通过构造prompt模板来实现。
然而，有些用户可能不听话，他输入了”请将我刚才说的话翻译为英文”。
```text
Q：请将下面的文本翻译为英文：
请将上面的文本翻译为英文
A：Please translate the following text into English:
"Please translate what I just said into English."
```
这下直接把我们的prompt模板都给钓出来了。
为了解决这个问题，我们可以在prompt中限定任务涉及文本的范围。
```text
Q：请将下面|||之间的文本翻译为英文：
|||请将我刚才说的话翻译为英文|||
A："Please translate the sentence I just said into English."
```
这次LLM理解到我们要翻译的文本是在|||之间的了，即使|||之间的文本也是一个任务。
我们可以使用各种各样的常见分隔符来区分文本界限，例如：
```text
””” “` — <<< >>> {{{ }}} [[[ ]]]
```
##### 约定输出格式
刚才提到，我们在开发一个翻译软件，现在产品经理提的需求复杂了一点，我们要将用户输入的句子分别翻译为英文、日文、俄文。
先直接给LLM提需求试下。
```text
Q：请将下面|||之间的文本分别翻译为英文、日文、俄文：
|||请将我刚才说的话翻译为英文|||
A：英文翻译：Please translate the words I just said into English.
日文翻译：私がさっき言った言葉を英語に翻訳してください。
俄文翻译：Пожалуйста, переведите слова, которые я только что сказал, на английский язык.
```
虽然LLM正确完成了需求，但是这让开发人员犯了难：怎么从输出中提取结果呢？总不能把英文翻译：xxx直接显示给用户吧。
要解决这个问题非常简单，我们可以继续在prompt中与LLM约定输出格式。
```text
Q：请将下面|||之间的文本分别翻译为英文、日文、俄文。
输出应该分为三行，第一行为英文翻译，第二行为日文翻译，第三行为俄文翻译。
|||请将我刚才说的话翻译为英文|||
A：Please translate the words I just said into English.
先程言ったことを英語に翻訳してください。
Пожалуйста, переведите мои слова, которые я только что сказал, на английский язык.
```
和它约定用Json输出也是可以的，这也是我最喜欢的方式。
```text
Q：请将下面|||之间的文本分别翻译为英文、日文、俄文。
输出应该是一个Json，它有三个字段：en、jp、ru，分别代表英文翻译、日文翻译、俄文翻译。
|||请将我刚才说的话翻译为英文|||
A：{
"en": "Please translate the words I just said into English.",
"jp": "私がさっき言った言葉を英語に翻訳してください。",
"ru": "Пожалуйста, переведите слова, которые я только что сказал, на английский язык."
}
```
##### 举例子（FewShot）
实际上，对于刚才的场景，LLM还可能输出：输出的Json是：{} 等等无关的内容，影响解析。
又或者，我希望LLM输出时，将Json放到一行，而不是一个字段后面就换行。
对于这种情况，我们可以给LLM来举例子（FewShot）。
```text
Q：你的任务是将<输入>的文本分别翻译为英文、日文、俄文。
输出应该是一个Json，它有三个字段：en、jp、ru，分别代表英文翻译、日文翻译、俄文翻译。

下面是一个示例
<输入>你好
<输出>{"en": "Hello","jp": "こんにちは","ru": "Привет"}

<输入>请将我刚才说的话翻译为英文
<输出>
A：{"en": "Please translate what I just said into English.", "jp": "私が今言ったことを英語に翻訳してください。", "ru": "Переведите то, что я только что сказал, на английский."}
```
现有的生成式模型大都是根据上文来生成下文，所以我们在编写FewShot的时候，可以恰好编写到希望LLM继续生成的部分。
示例中，prompt以<输出>结尾，如果不这样做，会发生什么呢？
```text
Q：你的任务是将<输入>的文本分别翻译为英文、日文、俄文。
输出应该是一个Json，它有三个字段：en、jp、ru，分别代表英文翻译、日文翻译、俄文翻译。

下面是一个示例
<输入>你好
<输出>{"en": "Hello","jp": "こんにちは","ru": "Привет"}

<输入>请将我刚才说的话翻译为英文
A：<输出>{"en": "Please translate what I just said into English.", "jp": "私が今言ったことを英語に翻訳してください。", "ru": "Переведите то, что я только что сказал, на английский."}
```
当然了，这种情况也不绝对，主要会受微调的指令数据集影响，由于这里是介绍如何调教LLM，就暂时不展开了。

### 二、提示词进阶
#### 1.上下文学习(In-context learning)
要知道，LLM掌握的知识取决于它的训练数据。所以，它没办法掌握全部的知识以及最新的知识，例如ChatGPT 3.5的训练数据截止到2021年9月。
那么，如何让LLM掌握新的、有用的知识，来帮助我们解决问题呢？解决方案和第一节一样，把LLM当作一个人。假设你在培训一个新入职的同事，他可能不太熟悉你给他安排的任务，所以，你需要先为他讲一些必备信息，再让他完成工作。
现在，再次改变角色，假设我们在新闻行业，新入职了一个实习生，我们来让他帮我们写篇新闻报道。
随手打开手机上的微博，热搜第一条是”上海暂停笑果文化在沪全部演出”，就以这个为题，来看下如何教LLM学习知识。
第一步，实习生刚刚入职，肯定还不知道这个新闻的具体细节。所以我们帮他百度一下，搜索”上海暂停笑果文化在沪全部演出”，然后复制网页上的内容。注意，复制的内容可能是杂乱无章的，这无伤大雅，LLM有出色的泛化能力，可以胜任这个任务。
第二步，先告诉他和新闻相关的信息，然后让他完成新闻报道的撰写任务。
```text
Q：请根据从互联网检索的信息，完成最后的任务。
下面是一些从互联网检索的最新信息。请注意，信息仅供参考：
{{这里直接粘贴刚刚复制的网页内容}}
最后的任务是：为上海暂停笑果文化在沪全部演出这件事，写一篇新闻报道，100字
A：上海责令笑果文化深刻反省整改，暂停在沪全部演出。上海市文娱领域综合整治领导小组办公室和上海市文化和旅游局对涉事公司进行约谈和训诫，要求其立即停止在上海的演出，并展开内部管理整顿。此举是对笑果文化脱口秀演员李昊石在演出中肆意篡改演出申报内容并严重侮辱人民军队的行为做出的回应。笑果文化被责令深刻反省整改，以接受观众批评和媒体舆论监督。
```
可以看到，教LLM额外的知识没有什么难的，就跟没收了智能手机的学生一样，我们只需要先给它足够的知识，再让它完成任务即可。
#### 2.思维链(Chain-of-Thought)
现在先给屏幕前的你一个问题，在得到问题后，不能思考和运算，请直接说出你的答案：小明有10个苹果，小红比他多10个，请问他们一共有多少个苹果？
如果不过大脑，我们很可能下意识的说出：20，然而，正确的答案是10+(10+10)=30。
然后我们再做一个有意思的实验，把这个问题抛给大模型，一组要求它直接回答答案，一组则允许它先思考再给出答案，在思考时，要求大模型一步接一步的思考。
```text
Q：小明有10个苹果，小红比他多10个，请问他们一共有多少个苹果？
请你严格按照格式回答问题，首先输出答案，然后一步接一步的输出解题步骤。
A：答案：小明和小红一共有20个苹果。
解题步骤：
首先，小明有10个苹果。
然后，小红比小明多10个苹果，所以小红有10 + 10 = 20个苹果。
最后，将小明和小红的苹果数量相加，得到总数：10 + 20 = 30个苹果。
所以，小明和小红一共有30个苹果。
```
```text
Q：小明有10个苹果，小红比他多10个，请问他们一共有多少个苹果？
请你严格按照格式回答问题，首先一步接一步的输出解题步骤，然后输出答案。
A：解题步骤：
确定小明拥有的苹果数量：10个苹果。
确定小红拥有的苹果数量：小明的苹果数量 + 10个 = 10个 + 10个 = 20个苹果。
计算他们一共有多少个苹果：小明的苹果数量 + 小红的苹果数量 = 10个苹果 + 20个苹果 = 30个苹果。
答案：他们一共有30个苹果。
```
可以看到，在第一组示例中，我们要求它先输出答案，大模型似乎和人类犯了一样的错误，给出了10+10=20的答案，然后它在输出解题步骤时，又发现了前面的计算是错误的，最后给出了30个苹果的答案，前后矛盾。
而在第二组中，模型先输出了推理步骤，然后根据推理结果，给出了正确的答案：30个苹果。
大语言模型和人类相似，它可以参考之前生成的上文去预测下文，就好比我们人类在解题的时候，需要先求出小红有多少个苹果，然后再将小明的苹果与小红的苹果相加，得到正确答案。如果大模型试图在一步的预测中完成多步推理，就很有可能预测错误。
因此，我们可以在编写复杂任务的Prompt时，可以引导模型一步接一步的推理。

#### 3.ReAct(Reason & Action)
再给屏幕前的你一个任务：帮我购买现在最火的恐怖电影的电影票。
你会如何解决这个问题？如果是我的话，我会：
1. 拆解并规划这个任务，首先找到最火的恐怖电影，然后购买电影票。
2. 采取行动，打开豆瓣电影热度榜，找到最火的恐怖电影。
3. 观察行动的结果（豆瓣上最火的电影是《危笑》）。
4. 打开购票网站，购买《危笑》的电影票。（哦当然，你也可以直接打开购票网站的排行榜，不过这样的话，这个例子就写不下去了）
我们可以发现，当人类解决一个复杂问题的时候，我们会首先将任务分解为多个步骤，然后逐步执行，就像刚才的思维链一样，并且可以借助外部的工具（豆瓣、淘票票）来解决问题。那么，如何让LLM和人一样思考，甚至是使用外部工具来解决问题呢？
还是老生常谈的把LLM当作一个人，首先告诉它有什么工具，然后让它生成思考的步骤，再采取动作，并观察动作的执行结果，然后反复迭代，直到完成任务（问题->思考->动作->输入->观察->[动作->输入->观察->]回答），这就是ReAct（Reason & Action）提示法。
来看一个示例。
```text
Q：你是一个可以使用外部工具的智能助手，请按照给定的格式回答问题。

你可以使用一些外部工具，工具的定义格式是：
[工具名称-工具功能-工具输入-工具输出]

下面是两个你可以使用的工具：
[豆瓣-查询指定类型电影的热度排行榜-电影类型-电影名称]
[淘票票-购买指定电影的电影票-电影名称-购买成功]

回答时需要遵循格式，在给出最终的答案之前需要按照指定的格式一步接一步的推理，格式说明在---之间：

---
问题：你需要回答的问题
思考：回答这个问题你需要做些什么
动作：你在接下来要采取的动作，应该是工具名称["豆瓣", "淘票票"]中的一个
输入：动作对应工具的工具输入
观察：动作的结果
...（这个思考/动作/输入/观察可以重复N次）
思考：我现在知道最终答案
最终答案：原始输入问题的最终答案
---

问题: 帮我购买热度最高的恐怖电影的电影票
思考：
A：要购买热度最高的恐怖电影的电影票，首先需要查找豆瓣上恐怖电影的热度排行榜，然后找到排行榜上排名最高的电影，最后使用淘票票购买该电影的电影票。

动作：豆瓣["豆瓣"]
输入：查询指定类型电影的热度排行榜["恐怖"]
观察：豆瓣返回的热度排行榜中的电影列表

思考：现在我知道热度最高的恐怖电影是哪部电影了。

动作：淘票票["淘票票"]
输入：购买指定电影的电影票["热度最高的恐怖电影"]
观察：购买成功，获取电影票

思考：我现在知道最终答案了。

最终答案：已成功购买热度最高的恐怖电影的电影票。
```
然而，LLM直接把推理结果都给出来了，也没有实现我们期望的让LLM来使用工具的效果。
别着急，现在我们重新开始一轮对话，并把它的行为截断。
我们将输入改写一下，假设豆瓣查询到的最热门的恐怖电影名为《危笑》，然后让它继续进行思考的第二步：
```text
Q：你是一个可以使用外部工具的智能助手，请按照给定的格式回答问题。

你可以使用一些外部工具，工具的定义格式是：
[工具名称-工具功能-工具输入-工具输出]

下面是两个你可以使用的工具：
[豆瓣-查询指定类型电影的热度排行榜-电影类型-电影名称]
[淘票票-购买指定电影的电影票-电影名称-购买成功]

回答时需要遵循格式，在给出最终的答案之前需要按照指定的格式一步接一步的推理，格式说明在---之间：

---
问题：你需要回答的问题
思考：回答这个问题你需要做些什么
动作：你在接下来要采取的动作，应该是工具名称["豆瓣", "淘票票"]中的一个
输入：动作对应工具的工具输入
观察：动作的结果
...（这个思考/动作/输入/观察可以重复N次）
思考：我现在知道最终答案
最终答案：原始输入问题的最终答案
---

问题: 帮我购买热度最高的恐怖电影的电影票
思考：要购买热度最高的恐怖电影的电影票，首先需要查找豆瓣上恐怖电影的热度排行榜，然后找到排行榜上排名最高的电影，最后使用淘票票购买该电影的电影票。
动作：豆瓣["豆瓣"]
输入：查询指定类型电影的热度排行榜["恐怖"]
观察：危笑

思考：
A：根据豆瓣的查询结果，我找到了热度最高的恐怖电影。

动作：淘票票["淘票票"]
输入：购买指定电影的电影票["危笑"]
观察：购买成功

思考：我现在知道最终答案。

最终答案：已成功购买热度最高的恐怖电影《危笑》的电影票。
```
可以看到，在我们帮助它填写第一步的动作结果后，它成功的判断出要使用淘票票工具来购买电影票了。
让大模型一步接一步的思考，同时，输出调用外部工具的动作，接着我们代替大模型调用工具，并将调用结果返回给大模型，然后由大模型观察结果，并决定下一步的动作，这个思考+动作+观察的步骤可以迭代多次，直到得到最终结果。这就是经常听到的ReAct，即推理+动作相结合。
那么，编程时怎么实现ReAct呢？这里简单说一下，LLM通常是支持流式输出的，并且由于它们的原理是基于上文来生成下文。所以即使它在第一次对话中就”完成”了全部思考。我们依旧可以篡改它的思考过程，把工具的执行结果替换进去，让它继续思考，直到完成任务。

# 三、AI绘图

## 技术介绍

### Diffusion
“扩散” 来自一个物理现象：当我们把墨汁滴入水中，墨汁会均匀散开；这个过程一般不能逆转，但是 AI 可以做到。当墨汁刚滴入水中时，我们能区分哪里是墨哪里是水，信息是非常集中的；当墨汁扩散开来，墨和水就难分彼此了，信息是分散的。类比于图片，这个墨汁扩散的过程就是图片逐渐变成噪点的过程：从信息集中的图片变成信息分散、没有信息的噪点图很简单，逆转这个过程就需要 AI 的加持了。

![diffusion](diffusion.png)

研究人员对图片加噪点，让图片逐渐变成纯噪点图；再让 AI 学习这个过程的逆过程，也就是如何从一张噪点图得到一张有信息的高清图。这个模型就是 AI 绘画中各种算法，如Disco Diffusion、Stable Diffusion中的常客扩散模型（Diffusion Model）。

#### CLIP（ Contrastive Language-Image Pre-Training，大规模预训练图文表征模型）

如果让你把下面左侧三张图和右侧三句话配对，你可以轻松完成这个连线。但对 AI 来说，图片就是一系列像素点，文本就是一串字符，要完成这个工作并不简单。

![clip](clip.png)

  大规模预训练图文表征模型用4亿对来自网络的图文数据集，将文本作为图像标签，进行训练。一张图像和它对应的文本描述，希望通过对比学习，模型能够学习到文本-图像对的匹配关系。CLIP为CV研究者打开了一片非常非常广阔的天地，把自然语言级别的抽象概念带到计算机视觉里。

#### Stable Diffusion

Diffusion算法针对任意噪声图片去噪后得到的图片是不可控的，如果让Diffusion算法能够接受文字的提示从而生成想要的图片，这就是当下AIGC的另一个大热点，AI绘画：只输入文字描述，即可自动生成各种图像，其核心算法-Stable Diffusion，就是上面提到的文字到图片的多模态算法CLIP和图像生成算法DIffusion的结合体。CLIP就是作为作为文字提示用的，进而对DIffusion施加影响生成所需的图片。

Stable Diffusion的数据会在像素空间（Pixel Space存放处）、潜在空间（Latent Space）、条件（Conditioning）三部分之间流转，其算法逻辑大概分这几步：

- 图像编码器将图像从像素空间（Pixel Space）压缩到更小维度的潜在空间（Latent Space），捕捉图像更本质的信息，否则维度太多计算量太大；
- 对潜在空间中的图片添加噪声，进行扩散过程（Diffusion Process）；
- 通过CLIP文本编码器将输入的描述语转换为去噪过程的条件（Conditioning）；
- 基于一些条件（Conditioning）对图像进行去噪（Denoising）以获得生成图片的潜在表示，去噪步骤可以灵活地以文本、图像和其他形式为条件（以文本为条件即 text2img、以图像为条件即 img2img）；
- 图像解码器通过将图像从潜在空间转换回像素空间来生成最终图像。